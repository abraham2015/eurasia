#summary EURASIA 用户手册（3.2 版）

<wiki:toc max_depth="2" />

|| || || ||
|| || ||
|| ||

= 安装 =

[http://eurasia.googlecode.com/svn/branches/3.2/eurasia.py 下载] [http://eurasia.googlecode.com/svn/branches/3.2/eurasia.py eurasia.py] 即可，无需安装。

{{{
$ wget http://eurasia.googlecode.com/svn/branches/3.2/eurasia.py
}}}

 * 需要 unix/linux 系统
 * 需要 libev、libeio 库和 greenlet 模块的支持
 * 在 python2.7 下测试通过（不支持 python3）

== 安装依赖 ==

安装 libev 库（将 libev.so 与 eurasia.py 放在同一目录即可）：

{{{
$ cvs -z3 -d :pserver:anonymous@cvs.schmorp.de/schmorpforge co libev
$ cd libev
$ chmod +x autogen.sh
$ ./autogen.sh
$ ./configure
$ make
$ cp .libs/libev.so /WHERE/IS/EURASIA_PY
}}}

安装 libeio 库（将 libeio.so 与 eurasia.py 放在同一目录即可）：

{{{
$ cvs -z3 -d :pserver:anonymous@cvs.schmorp.de/schmorpforge co libeio
$ cd libeio
$ chmod +x autogen.sh
$ ./autogen.sh
$ ./configure
$ make
$ cp .libs/libeio.so /WHERE/IS/EURASIA_PY
}}}

安装 greenlet 模块：

{{{
$ wget http://pypi.python.org/packages/source/g/greenlet/greenlet-0.4.0.zip
$ unzip greenlet-0.4.0.zip
$ cd greenlet-0.4.0
$ /PATH/TO/PYTHON setup.py build_ext --inplace
$ cp greenlet.so /WHERE/IS/EURASIA_PY
}}}

|| || || ||
|| || ||
|| ||

= 快速开始 =

{{{
from eurasia import httpserver
def handler(http):
    http.start_response('200 OK', [('Content-Type', 'text/html')])
    http.write('<html>Hello world</html>')
    http.close()

server = httpserver('0.0.0.0:8080', handler)
server.serve_forever()
}}}

执行脚本，使用浏览器访问 http://127.0.0.1:8080/ 即可。

== 地址格式 ==

接口 httpserver 允许多种形式的 addr 参数，例如字符串格式的 addr ：

{{{
server = httpserver('127.0.0.1:8080', handler)  # IPv4 地址，端口 8080
}}}

"(family, addr)" 格式的 addr ：

{{{
server = httpserver((socket.AF_UNIX, '/run/demo.sock'), handler)  # UNIX SOCK 地址
server = httpserver((socket.AF_AF_INET6, ('::', 8080)), handler)  # IPv$ 地址，端口 8080
}}}

== 启动多个服务器 ==

在需要启动多个服务器的时候，使用 server.start()、eurasia.run() 来代替 server.serve_forever() 。

{{{
import eurasia

    ...

server1 = eurasia.httpserver('0.0.0.0:8080', handler1)
server1.start()

server2 = eurasia.httpserver('0.0.0.0:8090', handler2)
server2.start()

eurasia.run()
}}}

 * 可以通过 server.stop() 来暂停服务器，暂停的服务器可以通过 server.start() 再次启动。

|| || || ||
|| || ||
|| ||

= http 对象 =

|| http.environ`[`_*headername*_`]` || 与 cgi/1.1 协议适配的 cgi 环境变量 ||
|| http.start_response (_*status*_, _*headers*_, _*timeout=-1*_) || 与 wsgi 协议适配的响应头发送函数 ||
|| http.read(_*size*_, _*timeout*=-1_) || 读取 http request content ||
|| http.readline(_*size*_, _*timeout*=-1_) || 读取 http request content ||
|| http.write(_*data*_, _*timeout*=-1_) || 发送 http response content ||
|| http.close(_*keep_alive*_=300, _*timeout*=-1_) || 完成 HTTP 响应 ||

 * http.write() 必须在 http.start_response() 后使用

== http.environ ==

可以通过 http.environ`[`_*envname*_`]` 获取的环境变量举例：

|| 环境变量： || 变量描述： || example： ||
|| REQUEST_METHOD || 请求的方法 || "GET"、"POST" ||
|| SERVER_PROTOCOL || 请求协议及版本 || "HTTP/1.1" ||
|| REMOTE_ADDR || 连入客户端的地址 || "192.168.0.2" ||
|| REMOTE_PORT || 连入客户端的端口 || 5566 ||
|| REQUEST_URI || 完整 uri || "/login?username=tom&passwd=***" ||
|| PATH_INFO || 页面地址 || "/login" ||
|| QUERY_STRING || 请求参数 || "username=tom&passwd=***" ||
|| CONTENT_TYPE || POST 等报文类型 || "application/x-www-form-urlencoded" ||
|| CONTENT_LENGTH || POST 等报文长度 || 999 ||
|| HTTP{{{_}}}_*HEADERNAME*_ || 普通头部 || HTTP_REFER："http://www.google.com/" ||

== http.close() 与 长连接 ==

如果浏览器支持 keep-alive 特性，服务器将会自动以 keep-alive 方式处理浏览器请求。

 * 服务器以 keep-alive 方式处理每一个请求
 * 默认情况下使用 http.close() 接口完成本次请求，并继续保持连接
 * 使用 http.close(0) 强制断开连接（无论是否完成）
 * http.close() 的 `keep_alive` 参数用于指定等待下次 http 请求所需的时间
 * http.close() 的 `timeout` 参数用于设定结束当次 http 请求所需的超时时间

== 超时 ==

多数 io 接口可以通过 timeout 参数设置超时，默认 -1 意为无超时。

{{{
from eurasia import httpserver, Timeout
def handler(http):
    http.start_response('200 OK', [])
    try:
        http.write(data, 10.) # 10 秒超时
    except Timeout as e:
        pass

server = httpserver('0.0.0.0:8080', handler)
server.serve_forever()
}}}

 * 带有超时的函数分别是 start_response()、read()、readline()、write()、close()

|| || || ||
|| || ||
|| ||

= 线程池 =

因为 eurasia 是基于协程实现的单进程、单线程服务器，因此需要借助线程池来完成阻塞调用。

在 eurasia 程序中，所有阻塞操作（包括文件、数据库等），必须通过 apply_ 函数来调用。

{{{
from eurasia import apply_

def handler(http):
    ...

    file = apply_(open, ('filename', 'r'))
    data = apply_(file.read, (200, ))

    ...
}}}

= 管道 =

可以使用 eurasia 提供的 popen3() 函数来操作协程管道，eurasia.popen3() 接口在操作上与 os.popen3() 类似。

{{{
from eurasia import popen3

def handler(http):
    ...

    stdin, stdout, stderr = popen3('ls', '-al')
    data = stdin.readline(1024, 10.) # 超时设为 10 秒
    stdout.write(data, 10.)

    ...
}}}

|| || || ||
|| || ||
|| ||


= 部署 =

eurasia 3.2 不再原生提供对多核处理器和 daemon 的支持，以下是 eurasia 3.2 推荐的部署方案。

  * 支持多核

    最简单的方法是在多个端口上启动多个独立的 eurasia 服务，数量与 cpu 核心相应，这样就可以充分使用 cpu 核心了。

    并通过 iptables（redirect）或者 lvs 做端口负载均衡。

  * 启动为 daemon

    推荐使用 [http://www.libslack.org/daemon/ daemon] 命令启动服务器。

    在多数 unix/linux 发行版上都可以非常方便地安装 daemon 命令。
#summary EURASIA 用户手册（3.2 版）

<wiki:toc max_depth="2" />

|| || || ||
|| || ||
|| ||

= 安装 =

[http://eurasia.googlecode.com/svn/branches/3.2/eurasia.py 下载] [[http://eurasia.googlecode.com/svn/branches/3.2/eurasia.py eurasia.py] 即可，无需安装。

{{{
$ wget http://eurasia.googlecode.com/svn/branches/3.2/eurasia.py
}}}

 * 需要 unix/linux 系统
 * 需要 libev、libeio 库和 greenlet 模块的支持
 * 在 python2.7 下测试通过（不支持 python3）

== 安装依赖 ==

安装 libev 库（将 libev.so 与 eurasia.py 放在同一目录即可）：

{{{
$ cvs -z3 -d :pserver:anonymous@cvs.schmorp.de/schmorpforge co libev
$ cd libev
$ chmod +x autogen.sh
$ ./autogen.sh
$ ./configure
$ make
$ cp .libs/libev.so /WHERE/IS/EURASIA_PY
}}}

安装 libeio 库（将 libeio.so 与 eurasia.py 放在同一目录即可）：

{{{
$ cvs -z3 -d :pserver:anonymous@cvs.schmorp.de/schmorpforge co libeio
$ cd libeio
$ chmod +x autogen.sh
$ ./autogen.sh
$ ./configure
$ make
$ cp .libs/libeio.so /WHERE/IS/EURASIA_PY
}}}

安装 greenlet 模块：

{{{
$ wget http://pypi.python.org/packages/source/g/greenlet/greenlet-0.4.0.zip
$ unzip greenlet-0.4.0.zip
$ cd greenlet-0.4.0
$ /PATH/TO/PYTHON setup.py build_ext --inplace
$ cp greenlet.so /WHERE/IS/EURASIA_PY
}}}

|| || || ||
|| || ||
|| ||

= 快速开始 =

{{{
from eurasia import httpserver
def handler(http):
    http.start_response('200 OK', [('Content-Type', 'text/html')])
    http.write('<html>Hello world</html>')
    http.close()

server = httpserver('0.0.0.0:8080', handler)
server.serve_forever()
}}}

执行脚本，使用浏览器访问 http://127.0.0.1:8080/ 即可。

==地址格式==

接口 httpserver 允许多种形式的 addr 参数。

{{{
server = httpserver('127.0.0.1:8080', handler)  # IPv4 地址，端口 8080
}}}

==创建多个服务器==

 * 通过 httpserver 创建多个 http 服务器
 * 服务器通过 start() 启动 / 以 stop() 暂停
 * 最后任意选择一个服务器执行 server_forever() 主循环或者运行 eurasia.run()
 * server 可以有多个，而 eurasia.run() 或 server.serve_forever() 只有一个

{{{
from eurasia import httpserver
def handler_1(http):
    http.start_response('200 OK', [('Content-Type', 'text/html')])
    http.write('<html>hello 1!</html>')
    http.close()

def handler_2(http):
    http.start_response('200 OK', [('Content-Type', 'text/html')])
    http.write('<html>hello 2!</html>')
    http.close()

server_1 = httpserver('0.0.0.0:8080', handler_1)
server_2 = httpserver('0.0.0.0:8081', handler_2)
server_1.start()
server_2.start()
server_2.serve_forever()
}}}

==http 对象==

操作 http 对象，获取请求，并完成相应。

主要属性及成员函数：

|| 字典（取出/写入） || httpfile.environ`[`_*headername*_`]` || 写入或者取得指定头部 ||
|| 成员函数 || httpfile.start_response (_*status*_, _*headers*_) || 设置响应 http 状态 status 和 http 头 headers ||
|| 成员函数 || httpfile.write(_*data*_, _*timeout*=-1_) || 发送内容，默认无超时 ||
|| 成员函数 || httpfile.close(_*keep_alive*_=300, _*timeout*=-1_) || 完成本次响应，默认设置 keep-alive 时间 300 秒||

==CGI 协议适配==

http 对象在设计上与 CGI/1.1 规范适配，以下是一些对应关系：

|| 接口类型： || 接口描述： || CGI 对应: ||
|| 字典 （读取/设置） || http.environ`[`_*envname*_`]` || 环境表量（environ） ||
|| 成员函数 || http.read(_*size*_, _*timeout*=-1_) || 标准输入（stdin）||
|| 成员函数 || http.readline(_*size*_, _*timeout*=-1_) || 标准输入（stdin） ||
|| 成员函数 || http.write(_*data*_, _*timeout*=-1_) || 标准输出（stdout） ||

可以通过 http.environ`[`_*envname*_`]` 获取的环境变量：

|| 环境变量： || 变量描述： || example： ||
|| REQUEST_METHOD || 请求的方法 || "GET"、"POST" ||
|| SERVER_PROTOCOL || 请求协议及版本 || "HTTP/1.1" ||
|| REMOTE_ADDR || 连入客户端的地址 || "192.168.0.2" ||
|| REMOTE_PORT || 连入客户端的端口 || 5566 ||
|| REQUEST_URI || 完整 uri || "/login?username=tom&passwd=***" ||
|| PATH_INFO || 页面地址 || "/login" ||
|| QUERY_STRING || 请求参数 || "username=tom&passwd=***" ||
|| CONTENT_TYPE || POST 等报文类型 || "application/x-www-form-urlencoded" ||
|| CONTENT_LENGTH || POST 等报文长度 || 999 ||
|| HTTP{{{_}}}_*HEADERNAME*_ || 请求头部 || HTTP_REFER："http://www.google.com/" ||

==解读请求==

通过 http.read(_*size*_, _*timeout*=-1_) 和 http.readline(_*size*_, _*timeout*=-1_) 读取报文体。

==完成响应==

通过接口 http.start_response(_*status*='200 OK'_, _*response_headers*=[]_, _*timeout*=-1_) 来设置_*响应头部*_：

{{{
def handler(http):
    response_status = '200 OK'
    response_headers = [('Content-Type', 'text/html')]
    http.start_response(response_status, response_headers)
    http.write('hello world!')
    http.close()
}}}

http.start_response() 发送指定的 status 和 headers 报文头，这和 wsgi 规范（[http://www.python.org/dev/peps/pep-0333/ pep333]）中 start_response() 接口的定义相近。

通过 http.start_response() 完成报文头部以后，就可以通过 httpfile.write(_*data*_, _*timeout*=-1_) 发送报文体了。

 * http.write() 必须在 http.start_response() 后使用

==长连接==

请求将被一直保持，直到你调用 `httpfile.close()` 在此期间你可以在任何时候向用户发送内容。

{{{
# -*- coding: utf-8 -*-
from eurasia import httpserver
from time import strftime
httpfiles = set()
def handler(current_http):
    response_headers = [('Content-Type', 'text/html; charset=utf-8')]
    current_http.start_response('200 OK', response_headers)
    current_http.write(strftime('[%a, %d-%b-%Y %H:%M:%S GMT] 我加入了<br/>'))
    # 通知其他在线用户，有新人加入
    disconnected_http = []
    for http in all_httpfiles:
        try:
            # 告诉其他在线用户
            httpfile.write(strftime('[%a, %d-%b-%Y %H:%M:%S GMT] 又有新人加入<br/>'))
        except:
            # 连接已断开
            disconnected_httpfile.append(httpfile)
    # 移除断开的 httpfile
    for httpfile in disconnected_httpfile:
        httpfiles.remove(httpfile)
    # 将当前客户端加入全局列表中
    httpfiles.add(current_httpfile)
server = httpserver('127.0.0.1:8080', handler)
server.serve_forever()
}}}

  * 请使用 firefox / chrome 浏览器观看此样例，因为缓存原因一些浏览器可能不能展现即时效果
  * handler 结束时，如果引用为零 httpfile 对象会自动销毁，并同时断开用户连接
  * httpfile.start_response() 与 httpfile.write() 都将立即发送数据_*没有缓存*_

== keep-alive ==

如果浏览器支持 keep-alive 特性，服务器将会自动以 keep-alive 方式处理浏览器请求。

 * 服务器以 keep-alive 方式处理每一个请求
 * 默认情况下使用 httpfile.close() 接口完成本次请求，并继续保持连接
 * 使用 httpfile.close(0) 强制断开连接（无论是否完成）

== tcpserver ==

使用 tcpserver(addr, app) 创建 tcp 服务器。

以下有两种可用的创建 tcp 服务器的方法：

方法一：

{{{
from eurasia import tcpserver

def handler(sock, addr):
    pass

server = tcpserver('0.0.0.0:8080', handler)
server.serve_forever()
}}}

方法二：

{{{
import socket
from eurasia import tcpserver

def handler(sock, addr):
    pass

server = tcpserver((socket.AF_INET, ('0.0.0.0', 8080)), handler)
server.serve_forever()
}}}

== 超时处理 ==

多数 web 接口可以通过 timeout 参数设置超时，timeout 是以秒为单位的浮点数（float），默认 -1 意思是无超时。

{{{
from eurasia import httpserver, Timeout

def handler(http):
    http.start_response('200 OK', [])
    try:
        http.write(data, 10.)
    except Timeout as e:
        print e.num_sent # 返回已经发送的字节数

server = httpserver('0.0.0.0:8080', handler)
server.serve_forever()
}}}

 * 发生超时，会抛出 eurasia.Timeout 异常，但是连接并不会随之中断
 * 用户仍然可以恢复因为超时中断的工作，这可能会导致一些潜在问题，因此建议断开连接并重试
 * 和 web 服务器不同，socket 服务器可以有效恢复因 timeout 而中断的工作，这将在后面的章节详解
 * 如果不捕获 timeout，异常将会传递到顶层，自动终止本次请求，断开连接

= 框架功能 =

== popen3 ==

使用 popen3 来操作管道。

{{{
from eurasia import popen3
stdin, stdout, stderr = popen3('ls', '-al')
}}}

== 线程池 ==

通过 apply_ 函数来实现异步文件读写。

{{{
from eurasia import apply_

fileobj = apply_(open, ('filename', 'r'))
data = apply_(fileobj.read, (200, ))
}}}

== 系统工具函数 ==

|| 接口：|| 说明：||
|| cpu_count() || 返回所有 cpu 核心总数 ||
|| setuid(_*user*_) || 设定运行时身份，可以指定用户名或者用户 id ||
|| setprocname(_*procname*_) || 指定进程名 ||

{{{
from eurasia import setprocname, setuid
setprocname('hello')

...

sock.bind(('', 80)) # bind 到 80 需要 root 权限
setuid('nobody') # 以 nobody 身份运行

...
}}}

 * setprocname() 需写在程序最前面


|| || || ||
|| || ||
|| ||


=部署=

eurasia 3.2 不再原生提供对多核处理器和 daemon 的支持，以下是 eurasia 3.2 推荐的部署方案。

  * 支持多核

    最简单的方法是在多个端口上启动多个独立的 eurasia 服务，数量与 cpu 核心相应，这样就可以充分使用 cpu 核心了。

    然后通过 iptables（redirect）或者 lvs 做端口负载均衡即可。

  * 启动为 daemon

    eurasia 推荐使用 [http://www.libslack.org/daemon/ daemon] 命令启动服务器。

    在多数 unix/linux 发行版上都可以非常方便地安装 daemon 命令。